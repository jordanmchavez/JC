- easy to change
	- most important
	- easy to understand structure and flow
	- easy to understand how to fix a bug / add a feature
	- easy to understand the implications of change: minimized unanticipated / opaque / nonobvious behavior
	- easy to understand makes it easy to go fast
	- unchangeable code will stagnate
	- convert hard-to-understand code into easy-to-understand code, especially frequently touched code, is the highest value add you can do as a programmer
- less > more
	- code is a liability
	- more code = harder to change (rule 1)
	- containers: dynamic arrays and hash tables
	- dont try to predict the future
	- tiniest solution to solve current needs
	- easier to take simplest possible solution and generalize than to change the wrong abstraction
	- delete unused code
	- no commented-out code
	- every abstraction / layer / level-of-indirection has a price
	- only abstract when it creates obvious value
	- if in doubt / on-the-fence, don't abstract
	- external libraries also add complexity: we don't own the code, nobody understands how it works so we can't change it
- explicit > implicit
	- it's okay if complex shit is complex, in fact it must be visibly/obviously complex: trying to make a complex operation appear simple by hiding it layers of abstraction is very bad
	- slow/expensive shit should be obviously slow/expensive in the code. don't overload operator= to copy a database.
- design for fast iteration
	- minimize build time by understand how the physical code structure causes slow compliation
	- minimize header inclusion, prefer forward declarations
	- avoid code-in-header: inlined functions are overrated. 
	- unit tests provide value, but only at the right level of granularity: test interfaces (which change infrequently), as opposed to implementation
	- the higher the volume:area ratio for a module
- abstraction
	- abstractions exist to hide complexity behind an interface that's simple compared to the implementation.
	- interface is the "surface area" of the abstraction: this is the "cost" of the abstraction, the part that we have to deal with. smaller is better (as long as its provides the needed functionality).
	- implementation is the "volume" of the abstraction: it's usually proportional to the complexity that the interface is hiding.
		- sometimes the volume is actual complexity, for example compression, http, rendering
		- sometimes the volume is just a bunch of simple things that need to be done together frequently, such as reading a file (open file, get size, alloc buffer, read contents)
	- an abstraction's value is the ratio of its surface area to its volume. Do not introduce an abstraction unless this ratio is high.
- coupling / dependencies
	- avoid coupling / dependencies: replace dependencies on concrete components with dependencies on interfaces
	- a component should say: "here are the things I need to work and here's how you provide them to me". it should not care how they're implemented or how/when they're created/initialized
- code responsibility
	- if you see a problem, it's your problem.
	- it's not sufficient to just fix a bug. figure out how the bug got there and how we can prevent similar bugs. can we make the bug impossible? can we add preventative measure in the code? can we add telemtry?
- readability > writability
	- don't be cute